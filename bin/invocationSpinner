#!/bin/bash

: ${INVOCATIONSPINNER_SUCCESS_DISPLAY_DELAY=0.3}
: ${INVOCATIONSPINNER_FAIL_DISPLAY_DELAY=1}

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--or-passthrough] [-m|--message MESSAGE [-C|--clear success|failure|all]] [--success SIGIL] [--fail SIGIL] [-T|--initial-delay TIMESPAN[SUFFIX]] -c|--command COMMANDLINE [...]|[--] SIMPLECOMMAND'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
plural()
{
    if [ "$1" = 1 ]; then
	printf %s "${2}${4}"
    else
	printf %s "${2}${3:-s}"
    fi
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Execute COMMAND while rotating a spinner regularly every second and faster in
case of (stdout / stderr) output.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --or-passthrough	When not connected to a terminal, omit MESSAGE,
			SIGIL(s), and any periodic updates. Basically, just
			execute COMMAND(s) without interfering in any way.
    --message|-m MESSAGE
			Text describing what COMMAND is doing for the user.
			If omitted, just periodic updates will be printed (and
			automatically cleared at the end).
    --success SIGIL	Append SIGIL after MESSAGE if COMMAND succeeds.
    --fail SIGIL	Append SIGIL after MESSAGE if COMMAND fails.
    --clear|-C success	Clear the MESSAGE if COMMAND succeeds.
			If --success is also given, will wait for
			$INVOCATIONSPINNER_SUCCESS_DISPLAY_DELAY $(plural $INVOCATIONSPINNER_SUCCESS_DISPLAY_DELAY second).
    --clear|-C failure	Clear the MESSAGE if COMMAND fails, i.e. returns a
			non-zero exit status.
			If --fail is also given, will wait for
			$INVOCATIONSPINNER_FAIL_DISPLAY_DELAY $(plural $INVOCATIONSPINNER_FAIL_DISPLAY_DELAY second).
    --clear|-C all	Clear the MESSAGE (and the periodic updates) regardless
			of whether COMMAND succeeds or not. If no MESSAGE has
			been given, the periodic updates will be cleared
			automatically.
    --initial-delay|-T TIMESPAN[SUFFIX]
			Wait for TIMESPAN before printing the message or
			appending / spinning / sweeping based on a line, or
			printing the first total running time. By default, the
			message is printed immediately. If COMMAND finishes
			earlier, no message (and SIGIL) get printed at all.
    --command|-c CMD	Execute the passed command line. When this is a simple
			command, it can also be passed as such.
EXIT STATUS:
    0	Complete success.
    1	Failed to write to the terminal.
    2	Bad invocation, wrong or missing command-line arguments.
    *   any exit status from COMMAND(s)

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '--foo bar /tmp/foobar'
}

hasMessage=
typeset -a args=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--message|-m)	args+=("$1" "$2"); shift; shift; hasMessage=t;;
	--)		args+=("$1"); shift; break;;
	*)		args+=("$1"); shift;;
    esac
done

typeset -a addedArgs=()
[ "$hasMessage" ] || addedArgs+=(--message '' --clear all)

INVOCATIONMESSAGE_SUCCESS_DISPLAY_DELAY="${INVOCATIONSPINNER_SUCCESS_DISPLAY_DELAY}" \
INVOCATIONMESSAGE_FAIL_DISPLAY_DELAY="${INVOCATIONSPINNER_FAIL_DISPLAY_DELAY}" \
    exec invocationMessage --spinner --timespan 0 --render-timer 1 "${addedArgs[@]}" "${args[@]}" "$@"
