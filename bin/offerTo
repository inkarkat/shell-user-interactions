#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Prompt the user whether to do WHAT (with -t|--timeout: for TIMEOUT seconds;
defaulting to no or what is set via -d|--default) and return 0 if the user
accepted, or 1 if the user declined. The user has to press y or n; other keys
restart the prompt, unless -a|--any-key is given (which then uses the default
for other keys). The prompt is cleared (unless -k|--keep-prompt is given).
HELPTEXT
    echo
    printf 'Usage: %q %s && COMMAND\n' "$(basename "$1")" '[-d|--default y[es]|n[o]|NUM] [-t|--timeout|--for SECONDS] [-a|--any-key] [-k|--keep-prompt] WHAT|- [-?|-h|--help]'
}

keepPromptSequence='[1G[2K' # Return cursor to the beginning of the current line and clear it.
typeset readArgs=()
isAnyKey=
timeout=
timeoutValue=
default=1
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--default|-d)	shift
			case "$1" in
			    yes|y)	default=0;;
			    no|n)	default=1;;
			    +([0-9]))	default=$1;;
			    *)		printf >&2 'ERROR: Bad default "%s".\n' "$1"; printUsage "$0" >&2; exit 2;;
			esac
			shift
			;;
	--any-key|-a)	shift; isAnyKey=t;;
	--keep-prompt|-k)
			shift; keepPromptSequence=;;
	--timeout|-t)	shift; readArgs+=(-t "$1"); timeoutPlural=s; [ "$1" = 1 ] && timeoutPlural=; timeoutValue="${1} second$timeoutPlural"; shift;;
	-)		break;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 1 ]; then
    printUsage "$0" >&2
    exit 2
fi
if [ "$1" = - ]; then
    what="$(< /dev/stdin)"
else
    what="$1"
fi

case "$default" in
    0)	choices="${isAnyKey:+*/}${timeout:+[}y${timeout:+]}/n";;
    *)	choices="y/${timeout:+[}n${timeout:+]}${isAnyKey:+/*}";;
esac
fullChoices="(${choices}${timeoutValue:+ within $timeoutValue})"
promptText="${what:-Do you want to?} $fullChoices"

if [[ -n "$keepPromptSequence" && ( ${#promptText} > ${COLUMNS:-80} || "$promptText" =~ $'\n' ) ]]; then
    # The output spans multiple terminal lines; need to determine how many to be
    # able to completely clear them.
    numLines=$(printf '%s' "$promptText" | nowrap --wrap | wc -l)
    keepPromptSequence="[$((${numLines:-2} - 1))F[0J" # Return cursor to the beginning of the previous $numLines lines and clear to end of screen.
fi

status=$default
while :
do
    choice="$(userquery -r -s -N 1 "${readArgs[@]}" -p "$promptText")"
    [ $? -gt 128 ] && break
    case "${choice,,}" in
	y)  status=0; break;;
	n)  status=1; break;;
	*)  [ "$isAnyKey" ] && break;;
    esac
    promptText=
done
printf >/dev/tty %s "${keepPromptSequence:-$'\n'}"
exit $status
